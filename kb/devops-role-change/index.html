<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Об менеджерское и инженерное рассмотрение процесса разработки - Об DevOps и архитектуру</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="Об менеджерское и инженерное рассмотрение процесса разработки"><meta itemprop=description content="Если продолжать обсуждать переход от документо-ориентированных (document-centric) процессов управления к программно-задаваемым (software-defined) (предыдущие посты: раз, два, три), легко упустить одно обстоятельство, которое одновременно наиболее ярко покажет совершившуюся революцию (и возможно окажется, что это революция консервативная).
А именно, ключевой фигурой, которая задает и контролирует некий процесс работы (например, процесс превращения фичи из замысла в код работающий на продакшне — через разработку, тестирование и другие стадии процесса разработки) перестал быть менеджер, как это было в документо-ориентированных процессах."><meta itemprop=datePublished content="2024-05-11T22:42:00+03:00"><meta itemprop=dateModified content="2024-05-11T22:42:00+03:00"><meta itemprop=wordCount content="752"><meta property="og:url" content="https://timurb.ru/kb/devops-role-change/"><meta property="og:site_name" content="Об DevOps и архитектуру"><meta property="og:title" content="Об менеджерское и инженерное рассмотрение процесса разработки"><meta property="og:description" content="Если продолжать обсуждать переход от документо-ориентированных (document-centric) процессов управления к программно-задаваемым (software-defined) (предыдущие посты: раз, два, три), легко упустить одно обстоятельство, которое одновременно наиболее ярко покажет совершившуюся революцию (и возможно окажется, что это революция консервативная).
А именно, ключевой фигурой, которая задает и контролирует некий процесс работы (например, процесс превращения фичи из замысла в код работающий на продакшне — через разработку, тестирование и другие стадии процесса разработки) перестал быть менеджер, как это было в документо-ориентированных процессах."><meta property="og:locale" content="ru-ru"><meta property="og:type" content="article"><meta property="article:section" content="kb"><meta property="article:published_time" content="2024-05-11T22:42:00+03:00"><meta property="article:modified_time" content="2024-05-11T22:42:00+03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Об менеджерское и инженерное рассмотрение процесса разработки"><meta name=twitter:description content="Если продолжать обсуждать переход от документо-ориентированных (document-centric) процессов управления к программно-задаваемым (software-defined) (предыдущие посты: раз, два, три), легко упустить одно обстоятельство, которое одновременно наиболее ярко покажет совершившуюся революцию (и возможно окажется, что это революция консервативная).
А именно, ключевой фигурой, которая задает и контролирует некий процесс работы (например, процесс превращения фичи из замысла в код работающий на продакшне — через разработку, тестирование и другие стадии процесса разработки) перестал быть менеджер, как это было в документо-ориентированных процессах."><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://timurb.ru/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://timurb.ru/css/main.css><link rel=stylesheet type=text/css href=https://timurb.ru/css/custom.css><link id=dark-scheme rel=stylesheet type=text/css href=https://timurb.ru/css/dark.css><script src=https://timurb.ru/js/main.js></script></head><body><div class="container wrapper"><div class=header><h1 class=site-title><a href=https://timurb.ru/>Об DevOps и архитектуру</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat><li><a href=../../about>Об авторе</a></li><li><a href=../../kb>Оглавление</a></li></ul></nav></div><div class=post><div class=post-header><div class=matter><h1 class=title>Об менеджерское и инженерное рассмотрение процесса разработки</h1></div></div><div class=meta><div class=date><small>Последнее обновление: 11 May 2024</small></div></div><div class=markdown><p>Если продолжать обсуждать переход от документо-ориентированных (document-centric) процессов управления к программно-задаваемым (software-defined) (предыдущие посты: <a href=https://t.me/devops_architecture/42>раз</a>, <a href=https://t.me/devops_architecture/44>два</a>, <a href=https://t.me/devops_architecture/45>три</a>), легко упустить одно обстоятельство, которое одновременно наиболее ярко покажет совершившуюся революцию (и возможно окажется, что это революция консервативная).</p><p>А именно, ключевой фигурой, которая задает и контролирует некий процесс работы (например, процесс превращения фичи из замысла в код работающий на продакшне — через разработку, тестирование и другие стадии процесса разработки) перестал быть менеджер, как это было в документо-ориентированных процессах. Для программно-задаваемых процессов этой ключевой фигурой снова стал инженер, как это было до выделения менеджмента как отдельной дисциплины.</p><p>Менеджера в общем мало интересует <em>содержание</em> отдельных работ, его интересует <em>выполнение взятых на себя обязательств</em> исполнителями: чтобы разработчики в срок разработали код фичи и передали его тестировщикам, чтобы тестировщики протестировали фичу и передали его для деплоя на продакшн и т.п. Одна из основных задач менеджера — контроль таких <em>обязательств</em>. Если тот, кому передали результаты некоторой работы подписал акт приемки, менеджеру в целом не важно, работает ли фича на самом деле, закрывает ли она потребности клиента, т.к. <em>обязательства</em> прописанные в контракте выполняются. Ошибка на продакшне это всего лишь повод либо добавить в контракт &ldquo;гарантийный срок на поставляемый результат&rdquo; (как <em>обязательство</em> устранять дефекты в течение этого срока), либо открыть отдельный контракт на поддержку. И это все совершенно нормально и правильно, т.к. контракт за выполнением которого он следит &ndash; это интерфейс через который взаимодействуют организации. Если контракт будет плохо соблюдаем, начнут сбоить сами взаимодействующие организации.</p><p>Инженера же, напротив, интересует в первую очередь <em>как именно</em> происходит работа. Не соблюденный <em>технологический процесс</em> не приведет к тому результату, который мы ожидаем, в непротестированном коде почти наверняка будут ошибки. При этом, любая инженерная деятельность по своей сути весьма неравномерна — разработчик не может сказать &ldquo;я написал код к фиче, как ее дальше будут тестировать и деплоить, и будет ли фича в принципе работать мне не важно&rdquo;. Почти всегда потребуется то или иное его участие и в других фазах. Ошибка найденная при тестировании или на продакшне возвращается к нему, и ее потребуется исправить. Для получения успешной системы в продакшне важно не только выполнение отдельных работ, но и <em>весь технологический процесс</em>, который поставляет результат в продакшн. В нем в отдельных фазах в принципе может не быть людей, а в других фазах могут участвовать одновременно несколько командных ролей, при этом у этих участников нет явно формализованной ответственности за участие в этой фазе. Если тестировщик нашел багу в написанном коде, разработчик садится с ним рядом и они вместе разбираются в чем там проблема, а не перекидывают тикеты друг другу (<em>"-Я протестировал и нашел ошибку. -А я исправил. -А я снова потестировал и снова нашел"</em>). При этом сбой на ранней стадии сквозного технологического процесса с большой вероятностью приведет к проблемам на его поздних стадиях, и поэтому этот процесс нужно проектировать также как и любой объект инженерной деятельности, и настолько же тщательно контролировать его реализацию: лучше всего описать его кодом чтобы получить гарантию что он всегда будет происходить именно так как проектировался.</p><p>Такое неоднородное вовлечение в процесс хорошо показано на &ldquo;Горбатой диаграмме&rdquo; из RUP:</p><p><img src=../../images/31039_original_1679766675017_0.jpg alt="Горбатая диаграмма RUP"></p><p>Слева на право происходят фазы процесса разработки (можно провести параллель с состояниями тикета на доске или шагами пайплайна).
Сверху вниз показаны роли, которые участвуют в каждой из фаз, и условный уровень их вовлечения в течение времени работы над проектом или фичей.</p><p>Итак, если рассмотреть особенности этих двух ролевые позиций &ndash; менеджера и инженера, то сразу становится ясна причина по которой звучат разные фантастические призывы вокруг DevOps, что мол &ldquo;devops-инженер должен наладить взаимодействие между разными командами&rdquo; &ndash; если смотреть на вещи как и прежде, с позиции менеджера, вполне закономерно будет казаться именно это. Но раз у нас происходит разворот от менеджмента к инженерии, это налаживание взаимодействия скорее становится новой задачей менеджера (и это уже будет какой-то другой вид менеджера, например, scrum-мастер или менеджер потока). Инженерной же задачей здесь будет организация собственно технологического процесса, и этот технологический процесс будет затрагивать не только собственно конвеер CI/CD, но и фазы архитектурного проектирования и анализа. Как я писал <a href=https://t.me/devops_architecture/45>чуть раньше</a>, эту самую инженерную задачу скорее всего будет формулировать руководитель разработки. Devops-инженер же будет реализовывать по этому заданию конкретные компоненты сквозного процесса &ndash; подобно тому как разработчики реализуют бизнес-функциональность приложения по спеке/набору user stories от владельца продукта.</p><p>И еще один момент. Глядя на это же самое обстоятельство нельзя ставить знак &ldquo;равно&rdquo; между ITIL и DevOps. ITIL &ndash; дисциплина для менеджеров, даже несмотря на то, что в 4й версии его авторы изо всех сил постарались сделать его инженерным. Глядя же, например, на <a href=https://web.devopstopologies.com/>DevOps-топологии</a> мы явно видим, что все топологии где идет речь о разграничении ответственности (т.е. о менеджерском взгляде на вещи) считаются антипаттерном для DevOps.</p></div><div class=tags></div><script src=https://utteranc.es/client.js repo=timurb/timurb.github.io issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script></div></div><div class="footer wrapper"><nav class=nav><div>2024 <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div></nav></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-XHRMHV11BE"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XHRMHV11BE")}</script></body></html>