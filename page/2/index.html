<!doctype html><html><head><meta name=generator content="Hugo 0.138.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Об DevOps и архитектуру </title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/rss+xml href=https://timurb.ru/index.xml title="Об DevOps и архитектуру"><meta itemprop=name content="Об DevOps и архитектуру"><meta itemprop=datePublished content="2024-11-06T19:01:23+03:00"><meta itemprop=dateModified content="2024-11-06T19:01:23+03:00"><meta property="og:url" content="https://timurb.ru/"><meta property="og:site_name" content="Об DevOps и архитектуру"><meta property="og:title" content="Об DevOps и архитектуру"><meta property="og:locale" content="ru_ru"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Об DevOps и архитектуру"><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://timurb.ru/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://timurb.ru/css/main.css><link rel=stylesheet type=text/css href=https://timurb.ru/css/custom.css><link id=dark-scheme rel=stylesheet type=text/css href=https://timurb.ru/css/dark.css><script src=https://timurb.ru/js/main.js></script></head><body><div class="container wrapper"><div class=header><h1 class=site-title><a href=https://timurb.ru/>Об DevOps и архитектуру</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat><li><a href=../../about>Об авторе</a></li><li><a href=../../kb>Оглавление</a></li></ul></nav></div><div class="recent-posts section"><div class=posts><div class=post><div class=post-header><div class=meta><div class=date><span class=day>28</span>
<span class=rest>Dec 2022</span></div></div><div class=matter><h4 class="title small"><a href=../../kb/methodology-practices/>Методология, дисциплины, практики</a></h4><span class=description><p><small>Reading time: 6 minutes</small></p><p>Существует мнение, что тяжеловесные подходы проектирования (ITIL, TOGAF, ГОСТ34 и т.д.) несовместимы с быстрыми частыми релизами и изменениями. А следовательно, зачем их изучать? Это верно только отчасти.</p><p>Во-первых вспомним всем известную методологическую максиму, которая упрощенно звучит как: <em>&ldquo;практика = дисциплина + технология&rdquo;</em>. И далее эта самая <em>практика</em> адаптируется под вполне конкретный контекст организации.</p><p><em>Дисциплина</em> описывает мотивацию, взаимоотношения с окружающим миром, онтологию и принципы. К примеру, CI/CD предназначено для ускорения поставки разрабатываемого софта в продакшн, состоит из последовательной цепочки преобразований, которую проходит описание фичи до продакшна (в процессе превращаясь в код, затем в некий набор артефактов), подразумевает активное участие команды в процессах этой цепочки, и наконец можно говорить о принципах Shift Left и Fail Fast как примере более частных описаний.</p><p><a href=../../kb/methodology-practices/>Read more...</a></p></span></div></div></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>12</span>
<span class=rest>Dec 2022</span></div></div><div class=matter><h4 class="title small"><a href=../../kb/release-deploy/>Релизы и деплои</a></h4><span class=description><p><small>Reading time: 3 minutes</small></p><p>Периодически поднимается тема того, чем отличается deploy от release, и на это есть элегантный ответ в недавно вышедшей <a href=https://pubs.opengroup.org/it4it/3.0/standard/_book-html.html>новой версии</a> стандарта <a href=https://pubs.opengroup.org/it4it/>IT4IT</a> от <a href=https://www.opengroup.org/>The Open Group</a>.</p><ul><li><p><a href=https://pubs.opengroup.org/it4it/3.0/standard/VSs_IT4IT-Value-Streams.html#VS_Deploy>Deploy</a> &ndash; это собственно инсталляция новой версии продукта на продакшн (сюда же включают и удаление старых версий с продакшна). В этот процесс входят и все стратегии деплоя &ndash; в том числе canary deploy, раскатка на какую-то небольшую часть аудитории, или деплой функциональности вообще прикрытой через feature flags и недоступной никому.</p><p><a href=../../kb/release-deploy/>Read more...</a></p></span></div></div></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>11</span>
<span class=rest>Dec 2022</span></div></div><div class=matter><h4 class="title small"><a href=../../kb/dora-research-review/>Исследование DORA и его проблемы</a></h4><span class=description><p><small>Reading time: 2 minutes</small></p><p>Кажется, спустя полтора года после прочтения книги Accelerate наконец удалось кратко и компактно сформулировать в чем проблема с <a href=https://cloud.google.com/devops/state-of-devops/>отчетом State Of Devops</a>.</p><p>Проблема в том, что в книге и отчете выпячивается та несомненно большая сложная часть работы по статистическим предсказаниям, которая однако по факту никому не нужна, и которая не имеет смысла.</p><ol><li><p>DORA статистически показали, что использование CI/CD приводит (&ldquo;предсказывает&rdquo;) к сокращению Lead Time, увеличению частоты поставки и снижению количества ошибок при развертывании.
На деле же это и есть основная функция CI/CD - он строится как раз для того, чтобы именно это и происходило.
Если ваш процесс CI/CD не приводит к ускорению поставки он не выполняет свою основную функцию, и скорее всего вы что-то делаете не так, и это можно сказать без исследований.
Ждем горячих заголовков &ldquo;Доказано научно: передвигаться на велосипеде быстрее чем пешком&rdquo;.</p><p><a href=../../kb/dora-research-review/>Read more...</a></p></span></div></div></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>06</span>
<span class=rest>Oct 2022</span></div></div><div class=matter><h4 class="title small"><a href=../../kb/roadmaps-for-iac/>Путь развития разработчика в Infrastructure as Code</a></h4><span class=description><p><small>Reading time: 2 minutes</small></p><p>Недавно вышли новые роадмапы профессионального развития на <a href=https://roadmap.sh/>https://roadmap.sh/</a> и они на мой взгляд очень хорошо помогают прояснить <a href=../../kb/iac-engineering>мой предыдущий пост</a> про то, что подход Infrastructure as Code — это особая форма разработки. Я не уверен, что согласен с <em>названиями</em> роадмапов, но разделение на роадмапы мне кажется очень хорошо сделанным:</p><ul><li><a href=https://roadmap.sh/software-architect>Software Architect</a> — список навыков указывают, что основные задачи это построение систем, состоящих из множества отдельно разрабатываемых компонентов (и интеграция этих компонентов между собой), коммуникация с разработчиками, другими архитекторами и руководством компании, и организация проекта. Одним словом, чтобы множество команд разработки и программные сервисы которые они разрабатывают интегрировались друг с другом и при этом решали бизнес-задачи. Нужны ли эти практики в подходе Infrastructure as Code? Не уверен, скорее всего если выходишь на такой уровень в организации тебе <em>уже</em> не нужен IaC, но вместе с тем практически все эти темы в той или иной мере затрагиваются если ты занимаешься методологией <a href=../../kb/devops-evolution>DevOps</a>.</li><li><a href=https://roadmap.sh/software-design-architecture>Software Design and Architecture</a> (напомню, что &ldquo;design&rdquo; переводится как &ldquo;проектирование&rdquo;) — список навыков указывает, что основные задачи это структурирование программного кода, разбиение на модули и интеграция между ними. Одним словом, все то, что нужно для того, чтобы код был не лапшой, а был поддерживаемым, тестируемым, изменяемым, надежным и т.п. Нужны ли эти практики в подходе Infrastructure as Code? Несомненно. Если размер инфраструктурного кода десятки тысяч строк, применение всех этих практик и концептов поможет справиться со сложностью и в относительно более декларативных языках — она в них с ростом кодовой базы растет медленнее чем в императивных, но все же растет. Отдельные принципы скорее всего неприменимым, но не столько неприменимы сами по себе, сколько по причине относительно более простой и относительно маленькой кодовой базы в случае инфраструктуры, и относительно стабильного пространства понятий которые мы при помощи IaC описываем.</li><li><a href=https://roadmap.sh/backend>Backend Developer</a> — здесь говорится об инструментах и концепциях применяемых собственно в процессе разработки. Что-то из этого если находимся в контексте инфраструктуры мы знаем и так, что-то становится применимо сразу же как-только мы начинаем заниматься SRE, а не только писать код. В целом кажется применимым не столько к IaC, сколько к SRE.</li></ul><p>Напомню свой тезис, который прозвучал в начале: практика <a href=iac-engineering>Infrastructure as Code</a> является не чем иным как программированием в &ldquo;особой&rdquo; доменной области на &ldquo;особом&rdquo; языке. Примерно так же как современное фронтенд-программирование имеет довольно мало общего с тем программированием на языке Паскаль, которое мы изучали в школе. Основные отличия находятся в решаемой проблематике и в конкретных языках программирования, которые применяются для решения задач.</p><p><a href=../../kb/roadmaps-for-iac/>Read more...</a></p></span></div></div></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>25</span>
<span class=rest>Sep 2022</span></div></div><div class=matter><h4 class="title small"><a href=../../kb/iac-engineering/>Инженерия и подход Infrastructure as Code</a></h4><span class=description><p><small>Reading time: 2 minutes</small></p><p>Подход &ldquo;Инфраструктура как код&rdquo; является ничем иным как особой формой разработки/программирования, и к этой форме разработки применимы большинство практик, принципов и паттернов, используемых в &ldquo;классическом программировании&rdquo;.</p><p>В статье <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> мимоходом отлично прояснен этот вопрос через определение того, что такое &ldquo;инженерия&rdquo;:</p><blockquote><p>Ideally the construction design phase results first into an ontological model of the object system, i.e. a white-box model that is completely independent of its implementation. Gradually this ontological model is transformed into more detailed (and more implementation dependent) whitebox models, the last one being the implementation model. This process is called implementation design or just engineering. If the object system is a software application, then the implementation model would be the source code in some programming language. The act of implementing consists of assigning appropriate technological means to the implementation model, e.g. running the source code on an appropriate platform.</p><p><a href=../../kb/iac-engineering/>Read more...</a></p></span></div></div></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>31</span>
<span class=rest>Aug 2022</span></div></div><div class=matter><h4 class="title small"><a href=../../kb/outsourcing/>Об outsourcing</a></h4><span class=description><p><small>Reading time: 3 minutes</small></p><p>Интересным, но не совсем понятным в <a href=../../kb/lifecycle-development/>современной парадигме разработки</a> становится место аутсорсинга в любом виде.</p><p>В &ldquo;классическом&rdquo; аутсорсинге некая внешняя организация выполняет некие работы для создания системы, которая нужна заказчику, передает ее заказчику, и на этом жизнь проекта заканчивается. Иногда бывает постпроект в виде &ldquo;поддержки&rdquo;, но это чаще всего совсем другой режим работы.
Иными словами, команда разработки создает систему, передает ее команде эксплуатации (которая как-то там ее поддерживает) и опционально подключается команда сопровождения для мелких багфиксов.</p><p><a href=../../kb/outsourcing/>Read more...</a></p></span></div></div></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>10</span>
<span class=rest>Aug 2022</span></div></div><div class=matter><h4 class="title small"><a href=../../kb/lifecycle-development/>Обеспечение жизненного цикла компонентов обеспечивающих жизненный цикл</a></h4><span class=description><p><small>Reading time: 1 minutes</small></p><p>Если ожидается, что наша система будет постоянно меняться, процесс эксплуатации становится важен настолько же, насколько важны и все остальные практики жизненного цикла &ndash; разработка, <a href=../../kb/testing-the-iac>тестирование</a>, сборка, интеграция и т.д.
Более того, все эти практики жизненного цикла становятся практически настолько же важны, как и сами функции приложения &ndash; те, которые предоставляются внешним пользователям.</p><p>Компоненты, обеспечивающие практики жизненного цикла (т.е. песочницы для разработчиков, автотесты, системы сборки, пайплайны CI/CD, система логирования и т.д.) становятся настолько же важны как и сами компоненты приложения — они теперь проектируются, разрабатываются, тестируются, эксплуатируются точно так же. Для них самих прорабатывается обеспечение жизненого цикла и интегрируются инструменты его автоматизации.
Этим в частности и отличается подход Infrastructure as Code от Infrastructure as Scripts. А именно, тем, что теперь инфракод (в т.ч. CI/CD, мониторинг и т.п.) это <strong>точно такой же программный компонент самого приложения</strong> как и, например, его web-фронтенд. Если же говорить про больший масштаб &ndash; инфра-компоненты будут точно такими же компонентами многокомпонентного приложения, примерно как “сервис нотификаций” или “сервис некоей бизнес-отчетности”.</p><p><a href=../../kb/lifecycle-development/>Read more...</a></p></span></div></div></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>06</span>
<span class=rest>Aug 2022</span></div></div><div class=matter><h4 class="title small"><a href=../../kb/decision-making/>Об принятие инженерных решений</a></h4><span class=description><p><small>Reading time: 5 minutes</small></p>Каждый раз когда мы говорим о реализации некоей системы (например, инфраструктурной платформы) одной из наших ключевых задач (возможно, важнейшей) будет принятие множества решений — как важных, так и не очень (нас интересуют важные). Эти решения самые разнообразные — решение о том, кто будет пользователями нашей системы, а кого оставляем за бортом, каким образом система будет устроена технологически, как мы ее будем реализовать и кто будет в нашей команде, и самое главное — будем ли мы эту систему реализовывать вообще, или будем жить дальше по старинке.<p><a href=../../kb/decision-making/>Read more...</a></p></span></div></div></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>05</span>
<span class=rest>Jul 2022</span></div></div><div class=matter><h4 class="title small"><a href=../../kb/teal-monolith/>Бирюзовый монолит</a></h4><span class=description><p><small>Reading time: 1 minutes</small></p><p>При разговоре о &ldquo;бирюзовых организациях&rdquo; или &ldquo;аджайле&rdquo; часто считают, что это организации плоские и без особой структуры. Мол хорошо мотивированные высококлассные специалисты могут сами организоваться наиболее эффективным образом.</p><p>Но давайте вспомним про закон Конвея — &ldquo;Организации проектируют системы, которые копируют структуру коммуникаций в этой организации&rdquo;.
Плоская структура без иерархии (либо развитой параллельной управляющей структуры в виде например HR или архитектурной функции) будет означать, что эта компания разрабатывает монолит. Свободное перемещение между командами и изменение их конфигурации и зон ответственности — то, что этот монолит будет сильносвязанным. Это действительно светлое будущее, или же мы движемся в будущее микросервисов?</p><p><a href=../../kb/teal-monolith/>Read more...</a></p></span></div></div></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>04</span>
<span class=rest>Apr 2022</span></div></div><div class=matter><h4 class="title small"><a href=../../kb/agile-engagement/>Вовлеченность и Agile</a></h4><span class=description><p><small>Reading time: 1 minutes</small></p><p>(из архива 2020)</p><p>Agile часто продают как способ повысить вовлеченность команды в процесс.
На деле все наоборот — <em>сначала</em> вовлеченность, <em>потом</em> Agile.</p><p>Возможно многие &ldquo;серебряные пули&rdquo; не работают именно потому что пытаются при помощи их решить то, что они <em>требуют</em>.</p><p>К примеру, DevOps пытаются применять для того, чтобы с его помощью улучшить скорость поставки фич в продакшн, хотя на деле наоборот - улучшение такой скорости (помимо всего прочего) приводит к DevOps.</p><p><a href=../../kb/agile-engagement/>Read more...</a></p></span></div></div></div><ul class=pagination><li class="page-item page-prev"><a href=../../ class=page-link aria-label=Previous><span aria-hidden=true>← Prev page</span></a></li><li class="page-item page-next"><a href=../../page/3/ class=page-link aria-label=Next><span aria-hidden=true>Next page →</span></a></li></ul></div></div></div><div class="footer wrapper"><nav class=nav><div>2024 <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div></nav></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-XHRMHV11BE"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XHRMHV11BE")}</script></body></html>